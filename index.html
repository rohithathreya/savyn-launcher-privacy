<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Savyn – Your phone as a second brain. Private. Encrypted. On-device.">
    <title>Savyn – The Extension of Your Mind</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300..900;1,9..144,300..900&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <nav class="nav-pill">
        <a href="/" class="logo">Savyn</a>
        <span class="nav-divider"></span>
        <button id="top-cta" class="nav-btn">Early Access</button>
    </nav>

    <canvas id="network-bg"></canvas>

    <main>
        <!-- Hero: The Statement -->
        <section class="hero">
            <h1 class="hero-title">
                <span class="line">Your phone.</span>
                <span class="line">Your brain.</span>
                <span class="line text-gradient">Your business.</span>
            </h1>
        </section>

        <!-- The Manifesto: Narrative Flow -->
        <section class="manifesto">
            <div class="text-block">
                <p>A good part of our lives runs through our phone.</p>
            </div>

            <div class="text-block">
                <p>It sees everything. Which apps you reach for. The places you visit. The articles you read. The
                    thoughts you type.</p>
            </div>

            <div class="text-block">
                <p>It has the data. It has the processing power. So why is it just a static grid of icons?</p>
            </div>

            <div class="text-block highlight">
                <p>Why not make it <em>the</em> second brain?</p>
            </div>

            <div class="text-block">
                <p>Savyn is the context layer across your digital life. It knows what you need, right now. It surfaces
                    the right link, the right screenshot, the right memory.</p>
            </div>

            <div class="text-block">
                <p>But a second brain is only useful if it's truly <strong>yours</strong>.</p>
            </div>
        </section>

        <!-- The Privacy Pledge -->
        <section class="privacy-pledge">
            <div class="pledge-card">
                <h2>No ads. <br>No tracking. <br>No cloud training.</h2>
                <p>Your data stays on your device. Encrypted. Private. We don't sell it because we don't even see it.
                </p>
                <p class="signature">This is the only way.</p>
            </div>
        </section>

        <!-- Final CTA: Email Form -->
        <section class="footer-cta" id="signup-section">
            <p>Ready to reclaim your attention?</p>

            <form action="https://formspree.io/f/YOUR_FORM_ID" method="POST" class="email-form">
                <input type="email" name="email" placeholder="Enter your email" required>
                <button type="submit">Early Access</button>
            </form>
        </section>

    </main>

    <footer class="footer">
        <div class="footer-row">
            <a href="privacy-policy.html">Privacy Policy</a>
            <span class="dot">·</span>
            <a href="mailto:support@savynlabs.com">Contact</a>
        </div>
        <div class="footer-row copyright">
            <span>© 2025 Savyn Labs</span>
        </div>
    </footer>

    <script>
        // ============================================
        // Network Background Animation
        // ============================================
        const canvas = document.getElementById('network-bg');
        const ctx = canvas.getContext('2d');
        
        let nodes = [];
        let connections = [];
        let animationProgress = 0;
        const nodeCount = 60;
        const connectionDistance = 150;
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function createNodes() {
            nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    radius: Math.random() * 2 + 1,
                    originX: -100 + (Math.random() * 200), // Start from left
                    delay: Math.random() * 2 // Staggered entry
                });
            }
        }
        
        function updateNodes() {
            animationProgress += 0.008;
            
            nodes.forEach((node, i) => {
                // Expand from left animation
                const expandProgress = Math.min(1, Math.max(0, animationProgress - node.delay) * 0.5);
                const targetX = node.originX + (node.x - node.originX);
                
                if (expandProgress < 1) {
                    node.currentX = node.originX + (node.x - node.originX) * easeOutQuart(expandProgress);
                    node.currentY = canvas.height / 2 + (node.y - canvas.height / 2) * easeOutQuart(expandProgress);
                } else {
                    // Float around after expanded
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Bounce off edges softly
                    if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                    if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
                    
                    node.currentX = node.x;
                    node.currentY = node.y;
                }
            });
        }
        
        function easeOutQuart(t) {
            return 1 - Math.pow(1 - t, 4);
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw connections
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.15)';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = (nodes[i].currentX || nodes[i].x) - (nodes[j].currentX || nodes[j].x);
                    const dy = (nodes[i].currentY || nodes[i].y) - (nodes[j].currentY || nodes[j].y);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < connectionDistance) {
                        const opacity = (1 - dist / connectionDistance) * 0.2;
                        ctx.strokeStyle = `rgba(212, 175, 55, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(nodes[i].currentX || nodes[i].x, nodes[i].currentY || nodes[i].y);
                        ctx.lineTo(nodes[j].currentX || nodes[j].x, nodes[j].currentY || nodes[j].y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw nodes
            nodes.forEach(node => {
                const x = node.currentX || node.x;
                const y = node.currentY || node.y;
                
                ctx.beginPath();
                ctx.arc(x, y, node.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(212, 175, 55, 0.4)';
                ctx.fill();
            });
        }
        
        function animate() {
            updateNodes();
            draw();
            requestAnimationFrame(animate);
        }
        
        // Initialize
        resize();
        createNodes();
        animate();
        
        window.addEventListener('resize', () => {
            resize();
            createNodes();
            animationProgress = 3; // Skip intro on resize
        });

        // ============================================
        // Scroll Observer
        // ============================================
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                }
            });
        }, { threshold: 0.2 });

        document.querySelectorAll('.text-block').forEach(el => observer.observe(el));

        // CTA button scroll
        document.getElementById('top-cta')?.addEventListener('click', () => {
            document.getElementById('signup-section')?.scrollIntoView({ behavior: 'smooth' });
        });
    </script>
</body>
</html>